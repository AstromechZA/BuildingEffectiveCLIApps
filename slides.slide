Developing Effective CLI Apps
In Golang or Otherwise
26 Jul 2017

Ben Meier
@benmeier_
https://github.com/AstromechZA/

* Background

- Developer at Oracle Cloud
- Python / Golang
- Building distributed services and CI tooling

* First a terrible introduction..

* .

Lets first establish what makes a *bad* command line interface.

You have a binary:

    $ ls -al demo
    -rwxr-xr-x  1 benmeier  staff   1.6M Jul 25 21:40 demo*

_"Solves_the_greatest_programming_problem_known_to_man!"_ - Developer

* Umm

    $ ./demo

    panic: runtime error: index out of range

    goroutine 1 [running]:
    main.main()
        /Users/benmeier/projects/go_workspace/src/github.com/AstromechZA/BuildingEffectiveCLIApps/demo/main.go:10 +0x23a

Not off to a good start..

: at least it told you what the panic was!

* Errr

    $ ./demo --help

    panic: runtime error: index out of range

    goroutine 1 [running]:
    main.main()
        /Users/benmeier/projects/go_workspace/src/github.com/AstromechZA/BuildingEffectiveCLIApps/demo/main.go:15 +0x1ef

Nope

    $ man ./demo
    No manual entry for ./demo

* So we try some arguments

    $ ./demo a
    panic: runtime error: index out of range

    goroutine 1 [running]:
    main.main()
        /Users/benmeier/projects/go_workspace/src/github.com/AstromechZA/BuildingEffectiveCLIApps/demo/main.go:15 +0x1ef

And finally get some output:

    $ ./demo a b
    Done.%
    $ echo $?
    0

Was that a good or bad thing?

Doesn't exactly _"Solve"_ anything!

* Need some help now

- Ask the developer...
- Stackoverflow...

`.`

`.`

`.`

`.`

`.`

- Finally find an old comment on a cached version of a Google Groups page telling us to run it with an *integer*and*a*string*.

* Aha!

    $ ./demo 10 world
    Hëllo  0	world
    Hëllo  1	world
    Hëllo  2	world
    Hëllo  3	world
    Hëllo  4	world
    Hëllo  5	world
    Hëllo  6	world
    Hëllo  7	world
    Hëllo  8	world
    Hëllo  9	world
    Done.%

* .

Now we can go and celebrate about how *awesome* free software is.

.image https://media.giphy.com/media/26ufcVAp3AiJJsrIs/giphy.gif

If you have interfaces like this, you can only go up from here!

* Prioritizing Improvement

* Changes

Lots of things that we can change here!

They generally fall in a few main areas:

1. Respect the users

2. Respect the environment

3. Transparency

We'll expand on these in the next slides and then implement some of them to improve the app.

* Respect the users

How do you _expect_ users, developers, noobs, and experts to use your app.

vs

How are users _actually_ going to use your app.

* Respect the environment

It doesn't always run in the same context as it does on your machine.

Users have different

- operating systems
- shells
- platforms
- screen sizes
- hardware
- character support
- ttys

* Transparency

Don't hide information that would be better out in the open.

- Provide points of contact
- Embed documentation
- Introspection
- Feedback/bug reports
- Changelogs

* Preparing for development : Versioning

* .

We can't track our improvements without any sense of versioning.

This feeds directly into your *issue*tracking* by tying bugs or feature requests to specific versions.

Types:

- Version strings (_what_version_is_this_meant_to_be_)
- Build dates (_when_was_this_created_)
- Commit SHA (_what_was_the_last_change_)
- Commit date (_when_was_the_last_change_)
- Publicly available MD5 or SHA checksums (_is_this_official_)

* Embedding a version string

Use [[semver.org][semver]], you probably don't need MAJOR.MINOR.PATCH, start with just MAJOR.MINOR.


    // this is pretty meh - can't use it anywhere else - can't update it easily
    const Version = "0.1"

Lets prefer a version file

    $ cat VERSION
    0.1

And build it in like

    var Version = "unknown"

``

    $ go build -ldflags "-X \"main.Version=$(cat VERSION)\""

* Do the same with Git info

    var CommitSHA = "unknown"
    var CommitDate = "1970-01-01T00:00:00Z"

``

    $ go build -ldflags "
        -X \"main.Version=$(cat VERSION)\"
        -X \"main.CommitSHA=$(git rev-parse --short HEAD)\"
        -X \"main.CommitDate=$(git show -s --format=%cI HEAD)\"
    "

Tools like [[https://github.com/ahmetb/govvv][govvv]] can do this for you, but bash is often good enough.

* And allow users to get it

    if versionFlag {
        fmt.Printf("Version: %s\n", Version)
        fmt.Printf("Git Commit: %s\n", CommitSHA)
        fmt.Printf("Git Date: %s\n", CommitDate)
        os.Exit(0)
    }

``

    $ ./demo --version
    Version: 0.1
    Git Commit: e1a06ec
    Git Date: 2017-07-20T23:06:18+02:00

Now we can log bugs, reproduce issues, and generally be responsible developers.

* Task 1 : A proper interface

* .

- Don't parse `os.Args` yourself
- *Always* check `len(os.Args)` if you are using positional arguments

Use an existing parser:

- `flag` (often good enough)
- [[https://github.com/spf13/cobra][github.com/spf13/cobra]]
- [[https://github.com/urfave/cli][github.com/urfave/cli]]
- ...

These give you more than just parsing, they also provide:

- `--help`
- "No such option --blah"
- Subcommands

* Developer gives us a version 0.1

    $ ./demo
    $ echo $?
    0

At least it didn't stack trace this time..

    $ ./demo --help
    This binary solves the greatest programming problem known to man! It will print 'N' rows of hello text.

    Usage:

    $ demo (options...) [N] [text]

    -version
            print the version information

``

    $ ./demo --version
    Version: 0.1
    Git Commit: e1a06ec
    Git Date: 2017-07-20T23:06:18+02:00

* Task 2 : Exit codes

* .

*Very*Important* when used in scripts, CI, recipes, automated environments

Some _traditional_ values, usually dictated by shells, but nothing official so just concentrate on `0` vs `1` - anything else probably won't be noticed unless its needed.

    func mainInner() error {
        if rand.Float32() > 0.5 {
            return errors.New("Dice says no!")
        }
        return nil
    }

    func main() {
        if err := mainInner(); err != nil {
            fmt.Printf("Error: %s\n", err.Error())
            os.Exit(1)
        }
    }

* Task 3 : Error messages

* Language

If an error occurs *always* include a reason and *suggest* a fix if possible

    USELESS: "could not open file"
    USEFUL: "could not open file '/bob': file does not exist"

An error message that includes a suggestions means one less question from the user.

"Could not write file '/something/else' due to a permission error. Make sure you have write permission on the file."

* Must you write errors to stderr?

Not necessarily. It often over-complicates things.

`stdout`-`stderr` are just standard ways of splitting output in most shells and `tty` environments.

I'd use it in a few cases:

- when stdout massively outweighs stderr (curl)
- when stdout contains binary or a stream of data (gzip)
- when errors don't halt the application (daemons, servers, etc.. )

Don't stress really.

* a final version..

* .

    ./demo --version
    Project: demo (https://github.com/AstromechZA/BuildingEffectiveCLIApps)
    Version: 0.2
    Git Commit: e1a06ec
    Git Date: 2017-07-20T23:06:18+02:00

``

    $ ./demo
    Error: expected 2 arguments [N] [text]; see --help for info
    $ echo $?
    1

``

    ./demo a world
    Error: failed to parse argument 1 as a number: strconv.Atoi: parsing "a": invalid syntax
    $ echo $?
    1

``

    $ ./demo 2 world
    Hëllo	0	world
    Hëllo	1	world

* Other CLI techniques, issues, and quirks

* stdin isn't always readable!

When running as a subprocess, `stdin` might not be attached to anything. Attempts to prompt the user may hang or fail.

    import "golang.org/x/crypto/ssh/terminal"

    ...

    if terminal.IsTerminal(os.Stdin.Fd()) {
        // prompt
        os.Stdin.Readline()
    }

Another option is [[https://github.com/andrew-d/go-termutil][github.com/andrew-d/go-termutil]].Isatty()

* Environment variables

1. Always document these in `--help`

2. Tell the user when they are affecting the execution (if possible)

3. Often a `--flag` is better

* Line rewriting and progress bars

Most terminals interpret control characters as more than just raw bytes.

- `\r` can reset the cursor to the line start
- `\b` can move the cursor one position to the left

Use these to continuously update a progress percentage or progress bar.

.image https://camo.githubusercontent.com/eee5cea40ce2618a44f2b0abc893634c4ffc7367/687474703a2f2f692e696d6775722e636f6d2f763047324a75472e6769663f7261773d74727565

*But*log*files*and*piped*output*don't*handle*these*well!*

Use the `IsTerminal` behaviour to detect this and fallback to a dumb indicator.

* Detecting the terminal size

Editors like `vi` and `nano` expand to fill the full size of the terminal.

Most terminals will respond to various syscalls with information about their dimensions (although this is platform dependent).

Some shells will detect and export the dimensions as environment variables `$LINES`/`$COLS`. Some terminals will also forward a signal (`SIGWINCH`) to the process to indicate that the dimensions were changed.

Again, see methods in [[https://godoc.org/golang.org/x/crypto/ssh/terminal][golang.org/x/crypto/ssh/terminal]].

Use this to adapt the width of tables, progress bars, and other things to the size of the users terminal.

_Remember_to_default_to_something_sensible_when_not_in_a_terminal!_

* Machine readable

In the spirit of the Linux philosophy, your app or tool should focus on doing *one*specific*thing* really well.

This means it is likely to be used to compose more complicated workflows.

So design it to be machine readable and to operate with the standard line-by-line tools like `grep`/`sed`/`head`/`tail` where necessary.

    Name        Age
    ---------------
    Ted.........39
    Robin.......37
    Barney......41

vs `--json`

    {"name": "Ted", "age": 39}
    {"name": "Robin", "age": 37}
    {"name": "Barney", "age": 41}

* Machine readable errors

This is one case where sending errors to `stderr` is great.

A calling program can detect the non-zero exit code and gather the `stderr` to return to the user.

    STDOUT: {"name": "Ted", "age": 39}
    STDOUT: {"name": "Robin", "age": 37}
    STDERR: Error: failed to format row 3/3
    STATUS: 1

* Subcommands

Subcommands can be convenient to keep things in one binary

    my-server serve -p 80
    my-server list-files
    my-server prepare

But observe the problems that come from going too far in this direction

- `docker` cli has >50 subcommands each with different (and conflicting) options.

Sometimes separate binaries are better

    my-server-serve -p 80
    my-server-prepare

* Using ANSI control codes

[[https://en.wikipedia.org/wiki/ANSI_escape_code][ANSI]] codes can be used to control:

- text color
- text style
- blinking
- window titles

Can work *very* well for user-centric tools and prompts.

But again, only work in tty's that will actual render them.

    ESC[38;5mmy important log lineESC[0m that you must look at

`--no-color`

* `man` pages

- Very platform specific
- Avoid

Why not `--help`, `--manual` piped into the pager?

* Allow `-` as a file

When you take a filepath as input, interpret "-" as the stdin file descriptor.

When you use a filepath as output, interpret "-" as stdout (put anything else on stderr).

* Config files

If you expect a config file, provide an example config in your `--help` or as an option:

    --generate-example-config   outputs an example json file on stdout and exits

This can help to keep your config example synchronised with the code that reads it.

    $ thing --generate-example-config > config.json
    $ thing --config ./config.json

* Short option flags can be dangerous

    -D --daemonize     runs the app in the background
    -d --dry-run       does not delete the system

* Combining short options can be dangerous

    -k                  do bad thing
    -o                  don't tell the user
    --ok                everything is awesome

``

    $ thing --ok
    $ thing -ok

Thankfully `flag` doesn't support combining options..

* Apply CI/CD practices

- Create functional and integration tests for your CLI
- Catch regressions before they merge
- Automatically release new versions to github/webserver/repository
- Combined with versioning, this removes a lot of the manual effort involved in maintaining your tools

* So to recap..

* Respect your users

- They _will_ need help
- Developers are also users
- So are machines
- Someone will try to run it via a Bash script through a Rails app and pass the output over HTTP in JSON to be manipulated in Javascript.
- Empower those who use it
- Provide remedy suggestions

* Respect your environment

- Bash is not the only shell
- Either restrict compilation to one platform, or commit to being cross platform.
- Sometimes there isn't a TTY
- Multi-byte characters may not display correctly
- Control codes may not function correctly
- Colours may not display at all

* Transparency

- Be contactable
- Make it easy to identify and reproduce bugs
- Explain your errors
